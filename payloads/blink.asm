.DSEG
	.BYTE 0x500
	data_start:
	vr0: .BYTE 2
	vr1: .BYTE 2
	vr2: .BYTE 2
	vr3: .BYTE 2
	vr4: .BYTE 2
	vr5: .BYTE 2
	vr6: .BYTE 2
	vr7: .BYTE 2
	vr8: .BYTE 2
	vr9: .BYTE 2

	data:
	values: .BYTE 256
	add_buffer: .BYTE 256
	wait_jmp_table: .BYTE 10
	alighn_bytes: .BYTE 218
	code:
	.BYTE 8
	loop:
	.BYTE 96
	wait0:
	.BYTE 32
	wait1:
	.BYTE 40
	wait2:
	.BYTE 16
	wait3:
	.BYTE 32
	wait4:
	.BYTE 16
	EOF:
	.BYTE 4
	scratch:
.CSEG
	;vr0 -> start of 'text' segment
	;vr1 -> address of registers
	;vr2 -> memory mapped io
	;vr3 -> data segment
	;vr4 -> scratch space
	;vr5 -> real reg
	;vr6 -> general purpose reg
	;vr7 -> general purpose reg
	;vr8 -> general purpose reg
	;vr9 -> general purpose reg

	reg_Value: 
		.dw code
		.dw vr0
		.dw 0x0020
		.dw data
		.dw scratch
		.dw 0x0000 
		.dw 0xDEAD
		.dw 0xBEEF
		.dw 0xCAFE
		.dw 0xBABE

	value_table:	.dw 0x0001,0x0203,0x0405,0x0607,0x0809,0x0a0b,0x0c0d,0x0e0f,0x1011,0x1213,0x1415,0x1617,0x1819,0x1a1b,0x1c1d,0x1e1f,0x2021,0x2223,0x2425,0x2627,0x2829,0x2a2b,0x2c2d,0x2e2f,0x3031,0x3233,0x3435,0x3637,0x3839,0x3a3b,0x3c3d,0x3e3f,0x4041,0x4243,0x4445,0x4647,0x4849,0x4a4b,0x4c4d,0x4e4f,0x5051,0x5253,0x5455,0x5657,0x5859,0x5a5b,0x5c5d,0x5e5f,0x6061,0x6263,0x6465,0x6667,0x6869,0x6a6b,0x6c6d,0x6e6f,0x7071,0x7273,0x7475,0x7677,0x7879,0x7a7b,0x7c7d,0x7e7f,0x8081,0x8283,0x8485,0x8687,0x8889,0x8a8b,0x8c8d,0x8e8f,0x9091,0x9293,0x9495,0x9697,0x9899,0x9a9b,0x9c9d,0x9e9f,0xa0a1,0xa2a3,0xa4a5,0xa6a7,0xa8a9,0xaaab,0xacad,0xaeaf,0xb0b1,0xb2b3,0xb4b5,0xb6b7,0xb8b9,0xbabb,0xbcbd,0xbebf,0xc0c1,0xc2c3,0xc4c5,0xc6c7,0xc8c9,0xcacb,0xcccd,0xcecf,0xd0d1,0xd2d3,0xd4d5,0xd6d7,0xd8d9,0xdadb,0xdcdd,0xdedf,0xe0e1,0xe2e3,0xe4e5,0xe6e7,0xe8e9,0xeaeb,0xeced,0xeeef,0xf0f1,0xf2f3,0xf4f5,0xf6f7,0xf8f9,0xfafb,0xfcfd,0xfeff
	add_table:		.dw 0x0001,0x0203,0x0405,0x0607,0x0809,0x0a0b,0x0c0d,0x0e0f,0x1011,0x1213,0x1415,0x1617,0x1819,0x1a1b,0x1c1d,0x1e1f,0x2021,0x2223,0x2425,0x2627,0x2829,0x2a2b,0x2c2d,0x2e2f,0x3031,0x3233,0x3435,0x3637,0x3839,0x3a3b,0x3c3d,0x3e3f,0x4041,0x4243,0x4445,0x4647,0x4849,0x4a4b,0x4c4d,0x4e4f,0x5051,0x5253,0x5455,0x5657,0x5859,0x5a5b,0x5c5d,0x5e5f,0x6061,0x6263,0x6465,0x6667,0x6869,0x6a6b,0x6c6d,0x6e6f,0x7071,0x7273,0x7475,0x7677,0x7879,0x7a7b,0x7c7d,0x7e7f,0x8081,0x8283,0x8485,0x8687,0x8889,0x8a8b,0x8c8d,0x8e8f,0x9091,0x9293,0x9495,0x9697,0x9899,0x9a9b,0x9c9d,0x9e9f,0xa0a1,0xa2a3,0xa4a5,0xa6a7,0xa8a9,0xaaab,0xacad,0xaeaf,0xb0b1,0xb2b3,0xb4b5,0xb6b7,0xb8b9,0xbabb,0xbcbd,0xbebf,0xc0c1,0xc2c3,0xc4c5,0xc6c7,0xc8c9,0xcacb,0xcccd,0xcecf,0xd0d1,0xd2d3,0xd4d5,0xd6d7,0xd8d9,0xdadb,0xdcdd,0xdedf,0xe0e1,0xe2e3,0xe4e5,0xe6e7,0xe8e9,0xeaeb,0xeced,0xeeef,0xf0f1,0xf2f3,0xf4f5,0xf6f7,0xf8f9,0xfafb,0xfcfd,0xfeff
	
jmp_wait: .dw wait0, wait1, wait2, wait3, wait4, loop
; we need to buffer this section so our 'code' does not cross a 0x100 segment. we could implement the branch handler routine but this is simpler and we have the space.
align: .db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7

code_:
	;mov DDRB, 0x80
	.dw vr3		;src data vreg
	.dw 0x80	;0x80 
	.dw vr2		;dst mmio
	.dw 0x04	;DDRB

loop_:
	;mov vr6L, PORTB
	.dw vr2		;src mmio
	.dw 0x05	;PORTB
	.dw vr1		;dst vreg
	.dw 0x06*2+1;vr6L

	;mov vr6H, 0x00
	.dw vr3		;src data vreg
	.dw 0x00	;0x00	
	.dw vr1		;dst vreg
	.dw 0x06*2	;vr6H

	;mov  PORTB, vr6 + 0x80
	.dw vr6				;src vr6
	.dw 0x80 + values	;vr6 + 0x80
	.dw vr2				;dst mmio
	.dw 0x05			;PORTB

	;set up wait.. tagert value and counter.. we will split the high an low bytes of both into sepreate registers so we wont need to keep doing this in the loop to save space.
	;mov vr6, 0x0001
	.dw vr3		;src data vreg
	.dw 0x00	;0x00	
	.dw vr1		;dst vreg
	.dw 0x06*2	;vr6H

	.dw vr3		;src data vreg
	.dw 0xA0	;0x01	
	.dw vr1		;dst vreg
	.dw 0x06*2+1;vr6L

	;mov vr7, 0x00ff
	.dw vr3		;src data vreg
	.dw 0x00	;0x00	
	.dw vr1		;dst vreg
	.dw 0x07*2	;vr7H

	.dw vr3		;src data vreg
	.dw 0xff	;0xff	
	.dw vr1		;dst vreg
	.dw 0x07*2+1;vr7L

	;counter
	;mov vr8, 0x0000
	.dw vr3		;src data vreg
	.dw 0x00	;0x00	
	.dw vr1		;dst vreg
	.dw 0x08*2	;vr6H

	.dw vr3		;src data vreg
	.dw 0x00	;0x01	
	.dw vr1		;dst vreg
	.dw 0x08*2+1;vr6L

	;mov vr9, 0x0000
	.dw vr3		;src data vreg
	.dw 0x00	;0x00	
	.dw vr1		;dst vreg
	.dw 0x09*2	;vr7H

	.dw vr3		;src data vreg
	.dw 0x00	;0xff	
	.dw vr1		;dst vreg
	.dw 0x09*2+1;vr7L

	;lets just do this once
	;mov r22, 0x00 
	.dw vr3		; data vreg
	.dw 0x00	; 0x00
	.dw vr5		; real reg
	.dw 0x16	; r22

; Nested loop magic
wait_0:
	; wait vr6:vr7.. count vr8:vr9
	; if test countH(vr8) == waitH(vr6): jmp wait3

	;mov [vr6+scratch], 0x01*2:	jmp inc_wait1
	.dw vr3		;src data vreg
	.dw 0x01*2	;0x01
	.dw vr6		;dst vr6
	.dw scratch	;vr6

	;mov [vr8+scratch], 0x02*2:	jmp wait3
	.dw vr3		;src data vreg
	.dw 0x03*2	;0x03 wail3
	.dw vr8		;dst vr6
	.dw scratch	;vr6

	;mov r23, vr6+scratch // check if they are the same and store jump distance
	.dw vr6		; vr6
	.dw scratch	; resualt
	.dw vr5		; real reg
	.dw 0x17	; r23

	;mov vip, [wait_jmp_table+(r22:r23)]
	.dw 0x16
	.dw wait_jmp_table + 1 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL

wait_1:
	; inc countL (vr9)
	;mov vr9L, vr9+1
	.dw vr9
	.dw values + 0x01
	.dw vr1
	.dw 0x09*2+1

	;if countL != 0x00
	;mov [scratch]+0x00, 0x01*2:	jmp inc_wait1
	.dw vr3		;src data vreg
	.dw 0x01*2	;0x02
	.dw vr4		;dst vr6
	.dw 0x00	;vr6

	;mov [vr9+scratch], 0x02*2:	jmp wait2
	.dw vr3		;src data vreg
	.dw 0x02*2	;0x02 wail2
	.dw vr9 	;dst vr8
	.dw scratch	;

	;mov r23, vr8+scratch // check if they are the same and store jump distance
	.dw vr4		; vr4
	.dw 0x00	; resualt
	.dw vr5		; real reg
	.dw 0x17	; r23

	;mov vip, [wait_jmp_table+(r22:r23)]
	.dw 0x16
	.dw wait_jmp_table + 1 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL

wait_2:
	;inc countH (vr8)
	;mov vr8L, vr8+1
	.dw vr8
	.dw values + 0x01
	.dw vr1
	.dw 0x08*2+ 1

	;mov vip, [wait_jmp_table+0]
	.dw vr3	;jmptable
	.dw 512 + 0x00*2+1 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL

wait_3:
	;if test countL == waitL: jmp wait5

	;mov [vr7+scratch], 0x04*2:	jmp inc_wait4
	.dw vr3		;src data vreg
	.dw 0x04*2	;0x04
	.dw vr7		;dst vr6
	.dw scratch	;vr6

	;mov [vr9+scratch], 0x05*2:	jmp wait5
	.dw vr3		;src data vreg
	.dw 0x05*2	;0x03 wail5
	.dw vr9		;dst vr6
	.dw scratch	;vr6

	;mov r23, vr7+scratch // check if they are the same and store jump distance
	.dw vr7		; vr6
	.dw scratch	; resualt
	.dw vr5		; real reg
	.dw 0x17	; r23

	;mov vip, [wait_jmp_table+(r22:r23)]
	.dw 0x16
	.dw wait_jmp_table + 1 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL

wait_4:
	; inc councL vr9
	;mov vr9L, vr9+1
	.dw vr9
	.dw values + 0x01
	.dw vr1
	.dw 0x09*2+1

	;jmp wait3
	;mov vip, [wait_jmp_table+0]
	.dw vr3
	.dw 512+0x03*2+0x01 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL
