.DSEG
	.BYTE 0x500
	data_start:
	vr0: .BYTE 2
	vr1: .BYTE 2
	vr2: .BYTE 2
	vr3: .BYTE 2
	vr4: .BYTE 2
	vr5: .BYTE 2
	vr6: .BYTE 2
	vr7: .BYTE 2
	vr8: .BYTE 2
	vr9: .BYTE 2

	data:
	values: 	.BYTE 256
	jmp_table: 	.BYTE 8

	code:
	uart_init:
	.BYTE 40
	loop:
	Rx:
	.BYTE 48
	doRx:
	.BYTE 8
	Tx:
	.BYTE 40
	doTx:
	.BYTE 8
	end:
	.BYTE 16

	scratch:

.CSEG
	;vr0 -> start of 'text' segment
	;vr1 -> address of registers
	;vr2 -> memory mapped io
	;vr3 -> data segment
	;vr4 -> scratch space
	;vr5 -> real reg
	;vr6 -> general purpose reg
	;vr7 -> general purpose reg
	;vr8 -> general purpose reg
	;vr9 -> general purpose reg

	reg_Value: 
		.dw code
		.dw vr0
		.dw 0x0020
		.dw data
		.dw scratch
		.dw 0x0000 
		.dw 0x0000
		.dw 0x0000
		.dw 0x0000
		.dw 0x0000
value_table:	.dw 0x0001,0x0203,0x0405,0x0607,0x0809,0x0a0b,0x0c0d,0x0e0f,0x1011,0x1213,0x1415,0x1617,0x1819,0x1a1b,0x1c1d,0x1e1f,0x2021,0x2223,0x2425,0x2627,0x2829,0x2a2b,0x2c2d,0x2e2f,0x3031,0x3233,0x3435,0x3637,0x3839,0x3a3b,0x3c3d,0x3e3f,0x4041,0x4243,0x4445,0x4647,0x4849,0x4a4b,0x4c4d,0x4e4f,0x5051,0x5253,0x5455,0x5657,0x5859,0x5a5b,0x5c5d,0x5e5f,0x6061,0x6263,0x6465,0x6667,0x6869,0x6a6b,0x6c6d,0x6e6f,0x7071,0x7273,0x7475,0x7677,0x7879,0x7a7b,0x7c7d,0x7e7f,0x8081,0x8283,0x8485,0x8687,0x8889,0x8a8b,0x8c8d,0x8e8f,0x9091,0x9293,0x9495,0x9697,0x9899,0x9a9b,0x9c9d,0x9e9f,0xa0a1,0xa2a3,0xa4a5,0xa6a7,0xa8a9,0xaaab,0xacad,0xaeaf,0xb0b1,0xb2b3,0xb4b5,0xb6b7,0xb8b9,0xbabb,0xbcbd,0xbebf,0xc0c1,0xc2c3,0xc4c5,0xc6c7,0xc8c9,0xcacb,0xcccd,0xcecf,0xd0d1,0xd2d3,0xd4d5,0xd6d7,0xd8d9,0xdadb,0xdcdd,0xdedf,0xe0e1,0xe2e3,0xe4e5,0xe6e7,0xe8e9,0xeaeb,0xeced,0xeeef,0xf0f1,0xf2f3,0xf4f5,0xf6f7,0xf8f9,0xfafb,0xfcfd,0xfeff

jmp_tab: .dw Rx, doRx, Tx, doTx

UART_INIT_:
	;mov 0x00C5, 0x00  	;mov UBRR0H, BAUD1
	.dw vr3 	; values
	.dw	0x00 	; 0x00
	.dw vr2		; mmio
	.dw 0xA5 	; 0xC5-0x20 = 0xA5 

	;mov 0x00C4, 0x67	;mov UBRR0L, BAUD2
	.dw vr3 	; values
	.dw	0x67 	; 0x67
	.dw vr2		; mmio
	.dw 0xA4 	; 0xC4-0x20 = 0xA4 

	;mov 0x00C0, 0x00 	;mov UCSR0A, U2X0
	.dw vr3 	; values
	.dw	0x00 	; 0x00
	.dw vr2		; mmio
	.dw 0xA0 	; 0xC0-0x20 = 0xA0 

	;mov 0x00C1, 0x18 	;mov UCSR0B, (1<<RXEN0)|(1<<TXEN0)
	.dw vr3 	; values
	.dw	0x18 	; 0x18
	.dw vr2		; mmio
	.dw 0xA1 	; 0xC1-0x20 = 0xA1 

	;mov 0x00C2, 0x86 	;mov UCSR0C, (2<<UNSEL0|(3<<UCSZ00)
	.dw vr3 	; values
	.dw	0x86 	; 0x86
	.dw vr2		; mmio
	.dw 0xA2 	; 0xC2-0x20 = 0xA2 

UART_Rx:
;check bit 7 of 0x00C0 if not set UART_Rx.. if there is data this and bit 5 are set (0xA0) 1010 0000
	;mov vr6, [0x00C0]
	.dw vr2			; mmio
	.dw 0xA0 		; 0xC0 - 0x20 = 0xA0
	.dw vr1			; virtual register
	.dw 0x06*2 + 1 	; vr6L

	;mov scratch+vr6, 0x0k	;jmp UART_Rx
	.dw vr3 	; values
	.dw 0x00*2 	; 0x00 jmp index
	.dw vr6 	; vr6
	.dw scratch ; scratch

	;mov scratch+0xA0, 0x0l	;jmp UART_doRx
	.dw vr3 	; values
	.dw 0x01*2 	; 0x01 jmp index
	.dw vr4 	; scratch
	.dw 0xA0 	; 0xE0
	
	;mov tmp, scratch+vrn	;get jump index
	.dw vr6 	; vr6
	.dw scratch	; scatch
	.dw vr1		; vregs
	.dw 0x07*2+1 	; vr7L

	;mov 0x00C0, 0x00 	;mov UCSR0A, U2X0
	.dw vr3 	; values
	.dw	0x40 	; 0x00
	.dw vr2		; mmio
	.dw 0xA0 	; 0xC0-0x20 = 0xA0 
	
	;mov XL, jmp_table + tmp	;jmp
	.dw vr7 			; vr7 is out jmp table index
	.dw jmp_table + 1 	; we want the low byte
	.dw vr5	 			; real reg
	.dw 0x1A   			; XL

UART_doRx:
	;mov vaule, [0x00C6] 	;mov value rcvd, 0x00C6
	.dw vr2			; mmio
	.dw 0xA6 		; 0xC6 - 0x20 = 0xA6
	.dw vr1 		; vreg
	.dw 0x08*2 + 1 	; vr8L

UART_Tx:
;check bit 5 of 0x00C0 if not set UART_Tx.. if we a good to go only this bit should be set (0x20) 0010 0000
	;mov vrn, [0x00C0]
	.dw vr2			; mmio
	.dw 0xA0 		; 0xC0 - 0x20 = 0xA0
	.dw vr1			; virtual register
	.dw 0x06*2 + 1 	; vr6L

	;mov scratch+vrn, 0x0m 	;jmp UART_Tx
	.dw vr3 	; values
	.dw 0x02*2 	; 0x0m jmp index
	.dw vr6 	; vr6
	.dw scratch ; scratch

	;mov scratch+0x20, 0x0n	;jmp UART_doTx
	.dw vr3 	; values
	.dw 0x03*2 	; 0x0l jmp index
	.dw vr4 	; scratch
	.dw 0x20 	; 0x20

	;mov tmp, scratch+vrn	;get jump index
	.dw vr6 	; vr6
	.dw scratch	; scatch
	.dw vr1		; vregs
	.dw 0x07*2+1 	; vr7L

	;mov XL, jmp_tavke + tmp	;jmp
	.dw vr7 			; vr7 is out jmp table index
	.dw jmp_table + 1 	; we want the low byte
	.dw vr5	 			; real reg
	.dw 0x1A   			; XL

UART_doTx_:
	;mov [0x00C6], vaule 	;mov 0x00C6, value to send
	.dw vr1 		; vreg
	.dw 0x08*2 + 1 	; vr8L
	.dw vr2			; mmio
	.dw 0xA6 		; 0xC6 - 0x20 = 0xA6

end_loop:


	;mov XL, jmp_tabe + 0x0k ;jmp UART_Rx
	.dw vr3
	.dw 256 + 0x00*2 + 0x01 
	.dw vr5				;dst mm reg
	.dw 0x1A			;XL
